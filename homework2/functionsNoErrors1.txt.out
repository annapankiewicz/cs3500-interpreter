TOKEN: IF 		 LEXEME: if
TOKEN: LPAREN 		 LEXEME: (
TOKEN: INTCONST 		 LEXEME: 4
CONST -> INTCONST
FACTOR -> CONST
TOKEN: POWER 		 LEXEME: ^
MULT_OP -> ^
TOKEN: INTCONST 		 LEXEME: 7
CONST -> INTCONST
FACTOR -> CONST
TOKEN: RPAREN 		 LEXEME: )
MULT_OP_LIST -> epsilon
MULT_OP_LIST -> MULT_OP FACTOR MULT_OP_LIST
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
TOKEN: LBRACE 		 LEXEME: {
TOKEN: IDENT 		 LEXEME: banana
TOKEN: ASSIGN 		 LEXEME: =
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
TOKEN: FUNCTION 		 LEXEME: function
TOKEN: LPAREN 		 LEXEME: (
TOKEN: IDENT 		 LEXEME: x
TOKEN: COMMA 		 LEXEME: ,
TOKEN: IDENT 		 LEXEME: y
TOKEN: COMMA 		 LEXEME: ,
TOKEN: IDENT 		 LEXEME: z
TOKEN: RPAREN 		 LEXEME: )
PARAMS -> IDENT
PARAMS -> IDENT, PARAMS
PARAMS -> IDENT, PARAMS
PARAM_LIST -> PARAMS
TOKEN: LBRACE 		 LEXEME: {
TOKEN: IDENT 		 LEXEME: x
TOKEN: ASSIGN 		 LEXEME: =
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
TOKEN: INTCONST 		 LEXEME: 2
CONST -> INTCONST
FACTOR -> CONST
TOKEN: SEMICOLON 		 LEXEME: ;
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
ASSIGNMENT_EXPR -> VAR = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: IDENT 		 LEXEME: y
TOKEN: ASSIGN 		 LEXEME: =
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
TOKEN: INTCONST 		 LEXEME: 3
CONST -> INTCONST
FACTOR -> CONST
TOKEN: SEMICOLON 		 LEXEME: ;
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
ASSIGNMENT_EXPR -> VAR = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: IDENT 		 LEXEME: z
TOKEN: ASSIGN 		 LEXEME: =
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
TOKEN: STRCONST 		 LEXEME: "BANANA"
CONST -> STRCONST
FACTOR -> CONST
TOKEN: SEMICOLON 		 LEXEME: ;
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
ASSIGNMENT_EXPR -> VAR = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: QUIT 		 LEXEME: quit
TOKEN: LPAREN 		 LEXEME: (
TOKEN: RPAREN 		 LEXEME: )
QUIT_EXPR -> QUIT()
EXPR -> QUIT_EXPR
TOKEN: RBRACE 		 LEXEME: }
EXPR_LIST -> epsilon
EXPR_LIST -> ; EXPR EXPR_LIST
EXPR_LIST -> ; EXPR EXPR_LIST
EXPR_LIST -> ; EXPR EXPR_LIST
COMPOUND_EXPR -> { EXPR EXPR_LIST }
FUNCTION_DEF -> FUNCTION ( PARAM_LIST ) COMPOUND_EXPR
EXPR -> FUNCTION_DEF
ASSIGNMENT_EXPR -> VAR = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: RBRACE 		 LEXEME: }
EXPR_LIST -> epsilon
COMPOUND_EXPR -> { EXPR EXPR_LIST }
EXPR -> COMPOUND_EXPR
TOKEN: ELSE 		 LEXEME: else
TOKEN: LBRACE 		 LEXEME: {
TOKEN: IDENT 		 LEXEME: apple
TOKEN: ASSIGN 		 LEXEME: =
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
TOKEN: FUNCTION 		 LEXEME: function
TOKEN: LPAREN 		 LEXEME: (
TOKEN: RPAREN 		 LEXEME: )
NO_PARAMS -> epsilon
PARAM_LIST -> NO PARAMS
TOKEN: LBRACE 		 LEXEME: {
TOKEN: PRINT 		 LEXEME: print
TOKEN: LPAREN 		 LEXEME: (
TOKEN: STRCONST 		 LEXEME: "fruit!"
CONST -> STRCONST
FACTOR -> CONST
TOKEN: RPAREN 		 LEXEME: )
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
OUTPUT_EXPR -> PRINT ( EXPR )
EXPR -> OUTPUT_EXPR
TOKEN: RBRACE 		 LEXEME: }
EXPR_LIST -> epsilon
COMPOUND_EXPR -> { EXPR EXPR_LIST }
FUNCTION_DEF -> FUNCTION ( PARAM_LIST ) COMPOUND_EXPR
EXPR -> FUNCTION_DEF
ASSIGNMENT_EXPR -> VAR = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: RBRACE 		 LEXEME: }
EXPR_LIST -> epsilon
COMPOUND_EXPR -> { EXPR EXPR_LIST }
EXPR -> COMPOUND_EXPR
IF_EXPR -> IF ( EXPR ) ELSE EXPR
EXPR -> IF_EXPR
START -> EXPR

---- Completed parsing ----

